#!/usr/bin/env bash

# ------------------------------------------------------------------
#      Script contains a collection of functions that
#
#      1. set postgres ENV vars ( changing default behaviour )
#      2. client tools ( modify the PATH )
#
#          client tools supported ( macports, dbngin, laravel herd )
#
#       TLDR call switch_postgres
# ------------------------------------------------------------------


# ---------- Postgresql 9.5 compatability  -------------------------
#
#      1. Clients tools prior to v12 should be ok to use (at a stretch)
#      2. Postgres extension dependency - hashlib extension
#
# ----------- üëç Compatible ----------------------------------------
#
#      1. macports - fully supports 9.5 and pghashlib
#      2. orbstack - fully supports 9.5 and pghashlib
#
# ----------- ‚úã Incompatible ( can't run postgres 9.5 ) -----------
#
#      brew, DBNGIN, Laravel Herd, EDB Postgres, Postgres.app
#          don't support 9.5 or their 9.5.xx versions are incompatible.
#
# ----------- üëç client tools + partial compatability ) ------------
#
#      1. DBNGIN - v10-16 ( <14 intel only )
#      2. Laravel Herd - v14-16
#
# ------------------------------------------------------------------

# Load PG ENV settings
export PGENV="$HOME/.pgenv"
[ -f "$PGENV" ] && source "$PGENV" || :;


if test -t 1; then
    # Determine if colors are supported...
    ncolors=$(tput colors)

    if test -n "$ncolors" && test "$ncolors" -ge 8; then
        BOLD="$(tput bold)"
        YELLOW="$(tput setaf 3)"
        GREEN="$(tput setaf 2)"
        RED="$(tput setaf 1)"
        NC="$(tput sgr0)"
    fi
fi

function switch_postgres() {
    if [ $# -ne 0 ]; then
        echo "no support for args in switch_postgres"
        return 0
    fi
    switch_postgres_cli_client "$@"
    echo
    switch_postgres_env_vars "$@"
    pgenv_store
}


function switch_postgres_cli_client() {
    if [ $# -ne 0 ]; then
        echo "no support for args in switch_postgres"
        return 0
    fi
    local pgversion
    local pgname
    echo ""
    echo -e "üêò Postgresql client\n--------------------"
    # PS3="Select client: "
    for pgversion in $(macports_postgresql_versions); do
        pgVerArr+=("MacPorts-$pgversion")
    done
    for pgversion in $(herd_postgresql_versions); do
        pgVerArr+=("Herd-$pgversion")
    done
    for pgversion in $(dbngin_versions); do
        pgVerArr+=("DBNgin-$pgversion")
    done
    select pgname in "${pgVerArr[@]}"; do
        pgversion="$(echo $pgname|cut -d'-' -f2)"
        if [ ! -n "$pgversion" ]; then
            echo "version unknown"
            return 1
        fi
        if echo "$pgname" | grep DBNgin &>/dev/null; then
            dbngin_use $pgversion
        elif echo "$pgname" | grep MacPorts &>/dev/null; then
            macports_postgresql_use $pgversion
        elif echo "$pgname" | grep Herd &>/dev/null; then
            herd_postgresql_use $pgversion
        fi
        break;
    done
    pgenv_store
    unset pgVerArr pgversion pgname PS3

}

function switch_postgres_env_vars() {

    if [ $# -eq 1 ]; then
        echo "no support for args in switch_postgres"
        return 0
    fi
    pgenv_set_host
    echo
    pgenv_set_port "$@"
    echo
    pgenv_set_user "$@"
    echo

    pgenv_show
    pgenv_store
}


# ------------------------------------------------------------------
# Standard Postgres environment variables -
#   these env vars, along with some custom env var, will be used to control the
#   shell's postgres behaviour, what version, path updates, etc.
#
# PGHOST behaves the same as the host connection parameter.
# PGHOSTADDR behaves the same as the hostaddr connection parameter. This can be set instead of or in addition to PGHOST to avoid DNS lookup overhead.
# PGPORT behaves the same as the port connection parameter.
# PGDATABASE behaves the same as the dbname connection parameter.
# PGUSER behaves the same as the user connection parameter.
# PGPASSWORD behaves the same as the password connection parameter. Use of this environment variable is not recommended for security reasons, as some operating systems allow non-root users to see process environment variables via ps; instead consider using the ~/.pgpass file (see Section 31.15).
# PGPASSFILE specifies the name of the password file to use for lookups. If not set, it defaults to ~/.pgpass (see Section 31.15).
#
# Postgres - align to linux and connect as postgres by default
# ------------------------------------------------------------------

# Aliases
alias pgdbs="psql -l -t | cut -d'|' -f1 | egrep -v 'postgres|template' | xargs"

function pg95mode() {
    # set pg95 alaises

    # PG95MODE - macports, orbstack

    local mode="${1}"

    if [[ "$mode" =~ "orb".* ]]; then

        export PG95MODE='orbstack'
        export PG95MACHINE="${PG95MACHINE:-postgres95}"

        alias pg95_start='orbctl -m $PG95MACHINE run systemctl start postgresql || echo PG95MACHINE=$PG95MACHINE'
        alias pg95_stop='orbctl -m $PG95MACHINE run systemctl stop postgresql || echo PG95MACHINE=$PG95MACHINE'
        alias pg95_restart='orbctl -m $PG95MACHINE run systemctl restart postgresql || echo PG95MACHINE=$PG95MACHINE'
        alias pg95_status='orbctl -m $PG95MACHINE run systemctl status postgresql || echo PG95MACHINE=$PG95MACHINE'

    else
        export PG95MODE='macports'

        # mac ports aliases - see sudo port install postgresql95-server
        alias pg95_start='sudo port load postgresql95-server'
        alias pg95_stop='sudo port unload postgresql95-server'
        alias pg95_restart='sudo port reload postgresql95-server'

        # use lunchy ( the launchctl helper ) to control launchd mac port service
        alias pg95_start='sudo lunchy start org.macports.postgresql95-server'
        alias pg95_stop='sudo lunchy stop org.macports.postgresql95-server'
        alias pg95_restart='sudo lunchy restart org.macports.postgresql95-server'
        alias pg95_status='sudo lunchy status org.macports.postgresql95-server;sudo lunchy show org.macports.postgresql95-server'

    fi

    export PGVERSION="${SWITCHED_PGVERSION:-${PGVERSION:-9.5}}" # this is not a standard PG ENV VAR

    echo -e "üêò Postgresql scripts loaded (9.5 env using '$PG95MODE' [$PGHOST:$PGPORT - $PGUSER] )"

}

function postgres_dev_init() {
    # after fresh install of postgres - setup basics
    if test ! -z "$PGUSER"; then
        createuser -s ${$PGUSER}
    fi
}


function dbngin_bin() {
    [ $# -ne 1 ] && {
        echo "Usage: PG_VERSION M.N"
        return 1
    }
    local dbngin_path="$(dbngin_path $1)"
    if [ -z "$dbngin_path" ]; then
        return 1
    fi
    echo "${dbngin_path}/bin"
}

function dbngin_json() {
    if [ ! -e "$HOME/Library/Application Support/com.tinyapp.DBngin/Data/DBEngines.plist" ]; then
        return 1
    fi
    echo $(plutil -convert json  "$HOME/Library/Application Support/com.tinyapp.DBngin/Data/DBEngines.plist" -o -) |jq
}

function dbngin_path() {
    [ $# -ne 1 ] && {
        echo "Usage: PG_VERSION M.N"
        return 1
    }
    ver=$1
    if [ ! -e "$HOME/Library/Application Support/com.tinyapp.DBngin/Data/DBEngines.plist" ]; then
        return 1
    fi
    echo $(plutil -convert json  "$HOME/Library/Application Support/com.tinyapp.DBngin/Data/DBEngines.plist" -o - | jq ".[]|select(.Version==\"$ver\")|.Binaries" | xargs)
}

function dbngin_port() {
    [ $# -ne 1 ] && {
        echo "Usage: PG_VERSION M.N"
        return 1
    }
    ver=$1
    if [ ! -e "$HOME/Library/Application Support/com.tinyapp.DBngin/Data/DBEngines.plist" ]; then
        return 1
    fi
    echo $(plutil -convert json  "$HOME/Library/Application Support/com.tinyapp.DBngin/Data/DBEngines.plist" -o - | jq ".[]|select(.Version==\"$ver\")|.Port" | xargs)
}

function dbngin_use() {
    local pgpath=$(dbngin_bin $1)
    if [ -z "$pgpath" ] && [ -e "$pgpath" ]; then
        return 1
    fi
    export_postgresql_bin_path $pgpath
    #export PGPORT=$(dbngin_port $1)
    #export PGHOST=localhost
}


function dbngin_versions() {
    if [ ! -e "$HOME/Library/Application Support/com.tinyapp.DBngin/Data/DBEngines.plist" ]; then
        return 1
    fi
    local versions
    for version in $(plutil -convert json  "$HOME/Library/Application Support/com.tinyapp.DBngin/Data/DBEngines.plist" -o - | jq '.[]|select(.Type=="PostgreSQL")|.Version' | xargs); do
        if [ -e "$(dbngin_bin $version)" ]; then
            versions+=("$version")
        fi
    done
    echo "${versions[@]}"
}

function export_postgresql_bin_path() {
    export PATH=$(echo $PATH | sed -E 's,/Users/Shared/DBngin/postgresql/[[:digit:]\.]+/bin:,,g')
    export PATH=$(echo $PATH | sed -E 's,/Users/Shared/Herd/services/postgresql/[[:digit:]\.]+/bin:,,g')
    export PATH=$(echo $PATH | sed -E "s,$(macports_postgresql_bin):,,g")
    export PG_CLIENT_PATH="$1"
    export PATH="$1:$PATH"
}


function local_postgres_process_ids() {
    ps aux | grep 'bin/[p]ostgres -D ' | grep -i "$1" | awk '{print $2}'
}

function local_postgres_pid_name_version_port() {
    # output csv list of postrgres services detected - pid,appname,version,port

    # look for any 'bin/postgres -D' commands in process list
    # pattern match AND pull out matching sections (pid, appname, version, port)
    # final grep , removes any postgres matches that do NOT fit the sed pattern

    local pglist="$(ps -ax -o pid -o command | grep 'bin/[p]ostgres -D ' \
        | sed -E 's/^[ ]*([0-9]+).*Shared\/([[:alpha:]]+)\/.*\/([0-9\.]+)\/bin\/postgres -D.* -p ([0-9]+).*/\1,\2,\3,\4/' \
        | grep ,)"

    if nc -z localhost 5432 &>/dev/null; then
        # find process ID on port 5432
        local pgpid="$(netstat -alnv |awk '{print $4","$11}'|sort|uniq|grep '\.5432,'| cut -d',' -f2|uniq)"
        if [ -n "$pgpid" ]; then
            # assume (look for) macports postgres install.
            local pgpidver=$(ps -p $pgpid -o command | sed 1d | sed -E 's#/opt/local/lib/postgresql([0-9\.]+)/bin/postgres.*#\1#' | sed -E 's/9([0-9])/9.\1/')
            if [ -n "$pgpidver" ]; then
                # append this record to the pglist
                pglist=$(echo -e "$pgpid,macPorts,$pgpidver,5432\n$pglist")
            else
                pglist=$(echo -e "$pgpid,Postgres,unknown,5432\n$pglist")
            fi
        fi
    fi
    echo "$pglist"
}

function local_postgres_choices_show() {
    # local onHost="${1:-${PGHOST:-localhost}}"
    local_postgres_pid_name_version_port | tr , ' '_ | awk '{print "PORT "$4" : " $2" v"$3}'
}

function local_postgres_process_ports() {
    # look for any 'bin/postgres -D' commands in process list
    local pids=$(ps aux | grep 'bin/[p]ostgres -D ' | awk '{print $2}' | xargs | tr ' ' ,)

    # get command with arguments only ( 1d to remove header)
    # apply any FILTER argument passed as $1
    local pgprocs=$(ps -p $pids -o command | sed 1d | grep -i "$1")

    local pgports

    # show non matched ports
    # echo "review $(echo "$pgprocs" | grep -v '\-p' | awk '{print $3}')/postgresql.conf"

    # for commands without specified port assume default port of 5432
    if echo "$pgprocs" | grep -v '\-p' &>/dev/null; then
        pgports=(5432)
    fi

    # add any specified ports ( that has been specified with -p argument )
    pgports+=($(echo "$pgprocs" | sed -r 's/.* -p ([0-9]+).*/\1/' | grep -Ew '[[:digit:]]+' | sort | uniq))
    echo "${pgports[*]}" | xargs

}

function pgenv_show() {
    echo "PGHOST          $PGHOST
PGHOSTADDR      $PGHOSTADDR
PGPORT          $PGPORT
PGDATABASE      $PGDATABASE
PGUSER          $PGUSER
PGPASSWORD      $PGPASSWORD
PGPASSFILE      $PGPASSFILE
PG_CLIENT_PATH  $PG_CLIENT_PATH
"
    # listen_addresses = '*' # todo add this the postgresql.conf files.
}

function pgenv_store() {
    pgenv_show | sed -E 's/^(PG[[:alpha:]_]+) +(.+)$/\1=\2/' > "$PGENV"
}

function pgenv_set_port() {
    # PGPORT
    local onHost="${1:-${PGHOST:-localhost}}"

    local pgOptions
    pgOptions=();
    for port in $(local_postgres_process_ports); do
        # validate port - check port is being listened on
        if nc -z $onHost $port &>/dev/null; then
            pgOptions+=($port);
        fi
    done

    # scan ports possibly... nah
    # nc -z localhost 5432-5532 2>&1 | awk '{print $5}' | xargs

    #PS3="üêò Set PGPORT:"
    echo -e "üêò Set PGPORT\n-------------"
    local_postgres_choices_show "$@"
    echo -e "-------------"
    local pgoption
    select pgoption in "${pgOptions[@]}"; do
        PGPORT=$pgoption
        break
    done
    if [ -z "$pgoption" ]; then
        PGPORT=${pgOptions[0]}
    fi

    export PGPORT
    unset pgOptions PS3 pgPorts pgoption
}

function pgenv_set_host() {
    # PGHOST
    local pgOptions
    pgOptions=(localhost)

    if type -t orbctl &>/dev/null; then
        # collect orb linux machine names
        pgOptions+=($(orbctl list -f json | jq '.[]|.name' | tr -d '"' | xargs -o printf -- '%s.orb.local ' ))
        # pgOptions+=(host.orb.internal)
    fi

    echo -e "üêò Set PGHOST\n-------------"
    #PS3="üêò Set PGHOST: "
    local pgoption
    select pgoption in "${pgOptions[@]}"; do
        PGHOST=$pgoption
        break
    done

    export PGHOST
    unset PS3 pgOptions pgoption
}

function pgenv_set_user() {
    # PGUSER
    echo -e "üêò Set PGUSER\n-------------"
    #PS3="üêò Set PGUSER: "
    local pgoption
    select pgoption in postgres homestead $(whoami) vagrant; do
        PGUSER=$pgoption
        break
    done
    export PGUSER
    unset PS3 pgOptions pgoption
}

function herd_postgresql_bin() {
    local pgversion="*${1/:-/}"

    if find /Users/Shared/Herd/services/postgresql -path "$pgversion/bin/psql" &>/dev/null; then
        find /Users/Shared/Herd/services/postgresql -path "$pgversion/bin" | sort | tail -1
        return
    fi
    return 1
}

function herd_postgresql_is_pathdefault() {
    # better check for pg_restore (rather that psql) as Laravel Herd places psql in the PATH explicitly via symlink (but not other client tools).
    [[ $(which pg_restore) =~ .*'/Herd/'.* ]]
}

function herd_postgresql_port() {
    for hpgv in $(dirname $(dirname $(ls /Users/Shared/Herd/services/postgresql/*/bin/psql))); do basename "$hpgv"; done | xargs
}

function herd_postgresql_use() {
    local pgpath=$(herd_postgresql_bin $1)
    if [ -z "$pgpath" ]; then
        return 1
    fi
    # remove existing postgresql from the path
    export_postgresql_bin_path $pgpath
    #export PGPORT=$(herd_port $1)
}

function herd_postgresql_versions() {
    for hpgv in $(dirname $(dirname $(ls /Users/Shared/Herd/services/postgresql/*/bin/psql))); do basename "$hpgv"; done | xargs
}

function macports_postgresql95_install() {
    if type -t port &>/dev/null && ! port &>/dev/null; then
        echo "http https://github.com/macports/macports-base/releases/download/v2.10.1/MacPorts-2.10.1-15-Sequoia.pkg; open MacPorts-2.10.1-15-Sequoia.pkg"
    fi
    sudo port install postgresql95-server
    read -p "Enter postgresql password for $(whoami) " _pgsecret
    sudo -u postgres psql -c "CREATE ROLE $(whoami) LOGIN PASSWORD '$_pgsecret' SUPERUSER INHERIT;"
}

function macports_postgresql95_is_pathdefault() {
    # better check for pg_restore (rather that psql) as
    # Laravel Herd places psql in the PATH explicitly via symlink (but not other client tools).
    [[ $(which pg_restore) =~ '/opt/local/lib/postgresql95/bin/pg_restore' ]]
}

function macports_postgresql95_is_installed() {
    [ -f /opt/local/lib/postgresql95/bin/psql ]
}

function macports_postgresql_bin() {
    dirname $(port -q contents postgresql95 | grep 'pg_restore$')
}

function macports_postgresql_path() {
    dirname $(macports_postgresql_bin "$@")
}

function macports_postgresql_use() {
    local pgpath=$(macports_postgresql_bin $1)
    if [ -z "$pgpath" ]; then
        return 1
    fi
    export_postgresql_bin_path $pgpath
    #export PGPORT=$(macports_port $1)
}

function macports_postgresql_versions() {
    port -q installed postgresql*-server | cut -d'-' -f1
}

function pghashlib_install() {

    PG_PORT="${PG_PORT:-5432}"

    if [ -n "$(dbngin_versions)" ]; then
        echo "DBngin PostgreSQL appears to be installed, the following versions are available ($(dbngin_versions))."
        read -p "Install against a DBngin PostgreSQL version or continue with default path (Enter for default)" dbnginchoice
        if [ -n "$dbnginchoice" ]; then
            echo "Temporarily setting PATH and PG_PORT for DBngin $dbnginchoice".
            export PATH="$(dbngin_path $dbnginchoice)/bin:$PATH"
            export PG_PORT=$(dbngin_port $dbnginchoice)
        else
            echo "Continuing on with default postgres version"
        fi
    fi


    # alternative
    #   - https://github.com/Cyan4973/xxHash
    #   - https://github.com/hatarist/pg_xxhash
    #   - https://github.com/fboulnois/pg_uuidv7
    #   - https://github.com/petere/pgvihash

    # extensions
    # https://gist.github.com/joelonsql/e5aa27f8cc9bd22b8999b7de8aee9d47
    # https://docs.digitalocean.com/products/databases/postgresql/details/supported-extensions/
    #

    HOMEBREW_NO_INSTALL_CLEANUP=true  HOMEBREW_NO_INSTALL_UPGRADE=true \
    brew install docutils # provides rst2html command
    pushd /tmp && \
    wget --quiet https://github.com/markokr/pghashlib/archive/master.zip -O pghashlib.zip && \
    echo "unzip" && unzip -o pghashlib.zip &>/dev/null && \
    pushd pghashlib-master && \
    echo "hashlib install" && \
    if [ -e "$(find $(pg_config --includedir) -name 'varatt.h')" ]; then
        # postgres 16+ fails for phhashlib
        # build failure on postgres16 - https://stackoverflow.com/questions/77617997/how-to-set-varsize-and-set-varsize-in-postgresql-16
        # append after match #include <fmgr.h> - src/pghashlib.h
        line=$(grep -n '#include <fmgr.h>' src/pghashlib.h | cut -d: -f1)
        sed -i '' "${line}s/^/#include <varatt.h>\n/" src/pghashlib.h
    fi &&
    echo "make" && make &>/dev/null && \
    env | grep -Ei 'PG_' && \
    echo "make install" && {
        touch $(pg_config --libdir)/test ||
        sudo make install &>/dev/null &&
        make install &>/dev/null
    } && \
    echo "hashlib done"

    popd && \
    echo "Tidyup hashlib" && \
    [ -e pghashlib-master ] && rm -rf pghashlib-master && \
    echo done
    # rm -f pghashlib.zip &>/dev/null || true

    popd

    psql -U $(whoami) -p $PG_PORT -c "create role postgres superuser login password '';" &>/dev/null || true
    psql -U postgres -p $PG_PORT -c "drop extension hashlib" &>/dev/null || true

    psql -U postgres -p $PG_PORT -c "create extension hashlib" && \
    [ $(psql -U postgres -p $PG_PORT -t -c "select encode(hash128_string('abcdefg', 'murmur3'), 'hex');" | head -1 | awk '{print $1}') == '069b3c88000000000000000000000000' ] \
        && echo 'pghashlib installed correctly' \
        || 'pghashlib not installed correctly'
    psql -U postgres -p $PG_PORT -c '\dx'

}

function fix_postgres() {
    echo "not using brew for postgres... exiting"
    return 0

    local PG_VERSION="${1:-${PGVERSION:-9.5}}"

    brew services stop postgresql@${PG_VERSION};
    mkdir -p /usr/local/var/postgresql@${PG_VERSION}/{{pg_commit_ts,pg_dynshmem,pg_replslot,pg_serial,pg_snapshots,pg_stat,pg_stat_tmp,pg_tblspc,pg_twophase},pg_logical/{mappings,snapshots}}
    rm -f /usr/local/var/postgresql@${PG_VERSION}/postmaster.pid &>/dev/null
    pgpids="$(ps ax  | grep 'postgre[s]ql\@' | awk '{print $1}')"
    [ -z "${pgpids}" ] && echo "NO postgres IDS found." || /bin/kill -SIGHUP "$pgpids" &>/dev/null
    brew services start postgresql@${PG_VERSION}
    sleep 2
    pghashlib_install
    psql -l
}

function _old_switch_postgres() {
    #
    # This switch postgresql assumes only 1 version of Postgres can be running and its on port 5432.
    #
    local PG_VERSION="${1:-${PGVERSION:-9.5}}"
    PG_VERSION_NO_DOT=$(echo "${PG_VERSION}"|tr -d '.')
    #
    # MacPorts Postgres
    #
    if [ -z "$PG_MATCHED" ] && [ -e "/opt/local/lib/postgresql${PG_VERSION_NO_DOT}" ]; then
        pgmacport_versions=$(find /opt/local/lib/postgresql* -maxdepth 0 | sed 's#/opt/local/lib/postgresql##g'| sort -n)
        echo "pgmacport_versions=$pgmacport_versions"
        if ! echo "$pgmacport_versions" | grep $PG_VERSION_NO_DOT; then
            echo "MacPorts Postgres $PG_VERSION is not installed"
        else
            PG_PGAPP=1
            PG_BINPATH="/opt/local/lib/postgresql${PG_VERSION_NO_DOT}/bin"
            if [ -e "$PG_BINPATH" ]; then
                PG_MATCHED=1
                echo "MacPorts Postgres $PG_VERSION is installed"
            else
                echo "MacPorts Postgres $PG_VERSION is not installed"
                PG_BINPATH=''
            fi
        fi
    else
        echo "MacPorts Postgres version not found"
    fi

    #
    # DBNgin
    #
    pgdbng_versions=$(dbngin_versions)
    if [ -z "$PG_MATCHED" ] && [ -n "${pgdbng_versions}" ]; then
        # match nearest maj.min.patch for DBngin
        PG_VERSION=$(for version in $pgdbng_versions; do echo "$version" | grep $PG_VERSION; done)

        if ! echo "$pgdbng_versions" | grep -q $PG_VERSION; then
            echo "DBngin Postgres $PG_VERSION is not installed"
        else
            PG_DBNGIN=1
            # match to closest maj.min.patch version
            PGVERSION=$(for v in $(dbngin_versions); do echo $v | grep '^11'; done)
            PG_BINPATH="$(dbngin_path $PGVERSION)/bin"
            export PG_PORT="$(dbngin_port $PGVERSION)"
            if [ -e "$PG_BINPATH" ]; then
                PG_MATCHED=1
                echo "DBngin Postgres $PG_VERSION is installed, on port $PG_PORT"
            else
                echo "DBngin Postgres $PG_VERSION is not installed"
                PG_BINPATH=''
            fi
        fi
        # can we stop DBNgin from the commandline ??
        for version in $pgdbng_versions; do
            echo "TODO - stop DBngin Postgres $version" > /dev/null
        done
        #echo "TODO - Start DBNgin from the commandline"
    else
        echo "DBngin Postgres version not found"
    fi

    unset PG_MATCHED

    #sed -i '' "/SWITCHED_PGVERSION/d" $PGVER_CONFIG
    #echo "SWITCHED_PGVERSION=$PG_VERSION # $(date)" >> $PGVER_CONFIG

    PGVERSION=$PG_VERSION
    export PGVERSION

    # clean and update PATH (check brew installed Postgres)
    CLEANED_PATH="$(echo $PATH | sed -E 's#/usr/local/opt/postgresql@[0-9.]*/bin[/]*[:]*##g')"
    # clean and update PATH (check DBNgin installed Postgres)
    CLEANED_PATH="$(echo $CLEANED_PATH | sed -E 's#/Users/Shared/DBngin/postgresql/[0-9.]*/bin[/]*[:]*##g')"
    # clean and update PATH (check Postgres.app installed Postgres)
    CLEANED_PATH="$(echo $CLEANED_PATH | sed -E 's#/Applications/Postgres.app/Contents/Versions/[0-9.]*/bin[/]*[:]*##g')"
    # clean and update PATH (check EDBPostgres installed Postgres)
    CLEANED_PATH="$(echo $CLEANED_PATH | sed -E 's#/Library/PostgreSQL/[0-9.]*/bin[/]*[:]*##g')"
    export PATH="$CLEANED_PATH"

    # set environment as per brew info for the service
    if [ -e "${PG_BINPATH}"/pg_config ]; then
        export PATH="$PG_BINPATH:$PATH"
        export LDFLAGS="$($PG_BINPATH/pg_config --ldflags)"
        export CPPFLAGS="$($PG_BINPATH/pg_config --cppflags)"
    fi

    echo "PATH updated for $PG_VERSION: $PG_BINPATH"

}


pg95mode "${PG95MODE:-orbstack}" #orbstack, macports

